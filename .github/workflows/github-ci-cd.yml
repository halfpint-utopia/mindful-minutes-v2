name: Django CI/CD

on:
  push: # Push the workflow when the code is pushed to the repo
    branches:
      - main # Trigger the workflow for the main branch

jobs:
  pull:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

  steps:
    - name: Checkout codebase # Step to check the codebase in the repo
      uses: actions/checkout@v2 # Uses the official checkout action

    - name: Login to Docker Registry # Step to log in to the Docker registry
      run: echo "${{ secrets.DOCKER_REGISTRY_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_REGISTRY_USERNAME }}" --password-stdin "${{ secrets.DOCKER_REGISTRY_URL }}"

    - name: Pull Docker image # Step to pull the latest Docker image
      run: docker pull ${{ secrets.DOCKER_REGISTRY_IMAGE }}:latest

  build:
    runs-on: ubuntu-latest # Run the job on Ubuntu environment

    steps:
      - name: Checkout codebase # Step to check the codebase in the repo
        uses: actions/checkout@v2 # Uses the official checkout action

      - name: Build Docker image # Step to build the Docker image
        run: docker build --tag=${{ github.run_id }}:${{ github:ref }} --cache-from=${{ secrets.DOCKER_REGISTRY_IMAGE }}:latest --pull .

  lint:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

    steps:
      - name: Checkout codebase # Step to check the codebase in the repo
        uses: actions/checkout@v2 # Uses the official checkout action

      - name: Lint # Step to run code linting
        run: docker-compose -f docker-compose.test.yml run app flake8 .

  test:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

    steps:
      - name: Checkout codebase # Step to check the codebase in the repo
        uses: actions/checkout@v2 # Uses the official checkout action

      - name: Test # Step to run tests
        run: |
          export CI_PIPELINE_ID=${{ github.run_id }}
          export CI_BUILD_REF_NAME=${{ github.ref }}
          docker-compose -f docker-compose.test.yml run app sh /scripts/test.sh

      - name: Archive coverage report # Step to archive the coverage report
        uses: actions/uploads-artifact@v2
        with:
          name: coverage-report
          path: htmlcov

  push_image:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

    needs: build # Dependency on build job

    if: github.ref == 'refs/heads/main' # Run the job only for the main branch

    steps:
      - name: Login to Docker Registry # Step to log in to the Docker registry
        run: echo "${{ secrets.DOCKER_REGISTRY_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_REGISTRY_USERNAME }}" --password-stdin "${{ secrets.DOCKER_REGISTRY_URL }}"

      - name: Tag Docker image # Step to tag the Docker image
        run: docker tag ${{ github.run_id }}:${{ github.ref }} ${{ secrets.DOCKER_REGISTRY_IMAGE }}:${{ github.ref }}

      - name: Push Docker image  # Step to push Docker image
        run: docker push ${{ secrets.DOCKER_REGISTRY_IMAGE }}:${{ github.ref }}

  push_latest:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

    needs: build # Dependency on build job

    if: github.ref == 'refs/heads/main' # Run the job only for the main branch

    steps:
      - name: Login to Docker Registry # Step to log in to the Docker registry
        run: echo "${{ secrets.DOCKER_REGISTRY_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_REGISTRY_USERNAME }}" --password-stdin "${{ secrets.DOCKER_REGISTRY_URL }}"

      - name: Tag Docker image as latest # Step to tag the Docker image as "latest"
        run: docker tag ${{ github.run_id }}:${{ github.ref }} ${{ secrets.DOCKER_REGISTRY_IMAGE }}:latest

      - name: Push Docker image  # Step to push the latest Docker image
        run: docker push ${{ secrets.DOCKER_REGISTRY_IMAGE }}:latest

  deploy_to_prod:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

    needs: test # Dependency on test job

    if: github.ref == 'refs/heads/main' # Run the job only for the main branch

    steps:
      name: Deploy to production # Step to deploy to production
      run: |
        docker-compose -f docker-compose.deploy.yml pull
        docker-compose -f docker-compose.deploy.yml down
        docker-compose -f docker-compose.deploy.yml up -d

  cleanup:
    runs-on: ubuntu-latest # Run the job on an Ubuntu environment

    always: true

    steps:
      - name: Cleanup # Step to perform cleanup actions
        run: |
          docker rmi -f ${{ github.run_id }}:${{ github.ref }}
          docker-compose -f docker-compose.test.yml down --remove-orphans